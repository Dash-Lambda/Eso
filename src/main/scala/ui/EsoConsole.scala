package ui

import ConsoleHandlers._
import brainfuck.{BFGenerator, BFManaged, FlufflePuff, Ook}
import common.{Generator, Interpreter, TransInterp, Translator}
import fractran.{FracTran, FracTranpp}
import scalarun.ScalaRun
import thue.Thue
import whitespace.{WSAssembly, WSManaged}

import scala.collection.mutable

object EsoConsole {
  val pointer: String = "Eso> "
  val welcomeText: String =
    """|Welcome to Eso, the functional esoteric language interpreter!
       |Type "help" for a list of commands.
       |""".stripMargin
  val defaultBindingFile: String = "userBindings.txt"
  val nativeTrans: Vector[Translator] = Vector[Translator](FlufflePuff, Ook, WSAssembly)
  val interpVec: Vector[Interpreter] = Vector[Interpreter](FracTran, FracTranpp, ScalaRun, WSManaged, BFManaged, Thue)
  val interpName: Vector[String] = interpVec.map(_.name)
  val genVec: Vector[Generator] = Vector[Generator](BFGenerator)
  
  val defBools: Vector[(String, (Boolean, String))] = Vector[(String, (Boolean, String))](
    "log" -> (true, "determines whether output is shown during or after runtime"),
    "debug" -> (false, "show runtime information, such as stack and heap states"),
    "dynamicTapeSize" -> (false, "resize tape as needed for BF interpreters, eliminates memory limitations but reduces speed"),
    "powExp" -> (false, "toggle raw value vs. factor expansion representation of FracTran output"),
    "WSL" -> (true, "toggle the use of SafeLongs with the WhiteSpace interpreter"))
  val defNums: Vector[(String, (Int, String))] = Vector[(String, (Int, String))](
    "BFOpt" -> (2, "BrainFuck interpreter selection: 0=base, 1=optimized, 2=compiled"),
    "initTapeSize" -> (40000, "initial tape length for BF interpreters"),
    "outputMaxLength" -> (-1, "maximum size of output string for interpreters, useful for non-terminating programs, -1 = infinite"),
    "dbTim" -> (0, "debug sleep time, slows down execution when debug is on, currently supported by FracTran++, WhiteSpace, and WhiteSpaceSL"),
    "methodSize" -> (1000, "maximum method length generated by the compiler, measured in optimized instructions, to work around JVM limitations"))
  
  private val userBindings: mutable.HashMap[String, Vector[String]] = mutable.HashMap[String, Vector[String]]()
  private val bools: mutable.HashMap[String, (Boolean, String)] = mutable.HashMap[String, (Boolean, String)]()
  private val nums: mutable.HashMap[String, (Int, String)] = mutable.HashMap[String, (Int, String)]()
  private val Translators: mutable.HashMap[(String, String), Translator] = mutable.HashMap[(String, String), Translator]()
  private val interpreters: mutable.HashMap[String, Interpreter] = mutable.HashMap[String, Interpreter]()
  private val generators: mutable.HashMap[(String, String), Generator] = mutable.HashMap[(String, String), Generator]()
  
  def main(args: Array[String]): Unit = {
    setDefaults()
    println(welcomeText)
    consoleLoop()
  }
  
  def setDefaults(): Unit = {
    Translators.clear()
    interpreters.clear()
    generators.clear()
    userBindings.clear()
    bools.clear()
    nums.clear()
    
    Translators ++= nativeTrans.map(t => ((t.name, t.baseLang), t))
    interpreters ++= interpVec.map(interp => (interp.name, interp))
    interpreters ++= nativeTrans.map(t => (t, interpreters.get(t.baseLang))).collect{case (t, Some(i)) => (t.name, TransInterp(t, i))}
    generators ++= genVec.map(comp => (comp.name, comp))
    userBindings ++= loadBindingsHandler(defaultBindingFile)
    bools ++= defBools
    nums ++= defNums
  }
  
  def addTrans(trans: Translator): Unit = {
    Translators += ((trans.name, trans.baseLang) -> trans)
    if(interpreters.isDefinedAt(trans.baseLang)) interpreters += (trans.name -> TransInterp(trans, interpreters(trans.baseLang)))
  }
  
  def consoleLoop(): Unit = {
    var runChk = true
    
    while(runChk){
      val inp = grabStr(s"$pointer").split(" ").toVector
      
      userBindings.get(inp.head) match{
        case Some(udb) => execCommand(udb ++ inp.tail)
        case None => execCommand(inp)
      }
    }
    
    def execCommand(inp: Vector[String]): Unit = inp match{
      case "run" +: args => runHandler(interpreters, bools, nums)(args)
      
      case "generate" +: args => generateHandler(generators, bools, nums)(args)

      case "optimize" +: args => optimizeHandler(bools, nums)(args)
      
      case "translate" +: args => translationHandler(bools, nums, Translators)(args)
      case "defineBFLang" +: _ => addTrans(langCreationHandler)
      case "loadBFLangs" +: args => for(p <- loadBFLangsHandler(args)) addTrans(p)
      case "saveBFLangs" +: args => bfLangSaveHandler(Translators, nativeTrans)(args)
      case "syntax" +: args => syntaxHandler(Translators)(args)
      
      case "bind" +: tok +: args => userBindings += ((tok, args))
      case "unbind" +: tok +: _ => userBindings -= tok
      case "clrBindings" +: _ => userBindings.clear
      case "loadBindings" +: args => userBindings ++= loadBindingsHandler(defaultBindingFile)(args)
      case "saveBindings" +: args => saveBindingsHandler(userBindings, defaultBindingFile)(args)
      case "listBindings" +: _ => listBindingsHandler(userBindings)
      
      case "set" +: args => println(setVarHandler(bools, nums)(args))
      case "defaults" +: _ => setDefaults()
      
      case "listLangs" +: _ => listLangsHandler(interpreters, Translators, generators)
      case "listVars" +: _ => println(printVarsHandler(bools, nums))
      case "help" +: _ => println(helpText)
      
      case "exit" +: _ =>
        println("Closing...")
        runChk = false
      
      case _ => println("Invalid command.")
    }
  }
}